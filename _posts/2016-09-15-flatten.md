---
layout: post
title: Array#flatten
---

If you work in Ruby, and probably in other dynamically typed languages,
you've likely had to make use of `flatten`. Say you have an array like
this: `[[3, [3, 3, 3]], [3, [3, 3, 3]], [3, [3, 3, 3]]]` and what you
_want_ is an array like this: `[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]`.

Trivial, you say: `array.flatten`.

What if you didn't have access to `flatten`? If you had to reimplement it,
what would you write?

Well, it's helpful, to me anyway, to think about how lists (arrays) are
recursive structures like trees. When we want to deal with deeply nested
recursive stuff, we can always turn to a recursive function:

```ruby
def flatten(array)
  flat = []
  rec_flat = proc {|a,f|
    a.each do |e|
      if e.is_a? Array
        rec_flat.call(e,f)
      else
        f << e
      end
    end
  }
  rec_flat.call(array,flat)
  flat
end
```

Though as I discussed in [more
recursion](http://mooreniemi.github.io/2016/09/08/more-recursion.html) we
want to be careful about exhausting the stack. So, let's manage the stack
ourselves manually:

```ruby
class Array
  def flat_stack
    flat = []
    stack = [] << self

    until stack.empty?
      e = stack.pop

      e.each do |a|
        if a.is_a? Array
          stack << a
        else
          flat << a
        end
      end
    end

    flat
  end
end
```

This is roughly how the [Ruby source
code](https://github.com/ruby/ruby/blob/trunk/array.c#L4533) handles the
situation, though you'll see they also take care to make sure recursive
references to the array inside the array don't cause an infinite loop.

I don't _really_ recommend rewriting this in Ruby, but the slowdown/memory
bloat is only a constant factor:

![performance of flatten vs flat_stack](/images/flatten_performance.jpg)
![memory usage of flatten vs flat_stack](/images/flatten_memory.jpg)

With the above disclaimer, there's one thing that bugs me about `flatten`
in Ruby. It's not open to a `block`. You can do `flatten {|e| p e }` but
you'll see Ruby just throws it away. Another common use case is
`flatten.compact`. Likewise, there's no way to tell `flatten` to ignore
any `nil` values. This is kinda a bummer to me because given `flatten` has
to traverse the entire data structure, we might want to save ourselves
a constant factor by piggybacking on that traversal.

So here's a version of `flat_stack` that gives us that flexibility:

```ruby
class Array
  def flat_stack(keep_nil = true)
    flat = []
    stack = [] << self

    until stack.empty?
      e = stack.pop

      e.each do |a|
        if a.is_a? Array
          stack << a
        else
          a = yield a if block_given?
          if keep_nil
            flat << a
          else
            flat << a unless a.nil?
          end
        end
      end
    end

    flat
  end
end
```

However, it still is better, performance-wise, to just use
`flatten.compact`:

![flat_stack](/images/flatstack.jpg)

Though just utilizing the block and not the compaction is a little better
performing, still not worth using over the normal idiom.
